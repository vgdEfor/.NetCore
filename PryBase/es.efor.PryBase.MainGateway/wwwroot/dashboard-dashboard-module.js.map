{"version":3,"sources":["./src/app/pages/main/dashboard/dashboard.module.ts","./node_modules/@angular/youtube-player/fesm2015/youtube-player.js","./src/app/pages/main/dashboard/dashboard.component.ts","./src/app/pages/main/dashboard/dashboard.component.html"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACM;AACY;AACJ;AACD;AACQ;AACO;;;;AAGrE,MAAM,MAAM,GAAW;IACrB,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,uEAAkB,EAAE;CAC5C,CAAC;AAYK,MAAM,eAAe;;8FAAf,eAAe;wJAAf,eAAe,kBARjB;YACP,4DAAY;YACZ,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC;YAC7B,mEAAe,CAAC,QAAQ,EAAE;YAC1B,2EAAmB;YACnB,kFAAiB;SAClB;mIAEU,eAAe,mBATX,uEAAkB,aAE/B,4DAAY,qIAGZ,2EAAmB;QACnB,kFAAiB;6FAGR,eAAe;cAV3B,sDAAQ;eAAC;gBACR,YAAY,EAAE,CAAC,uEAAkB,CAAC;gBAClC,OAAO,EAAE;oBACP,4DAAY;oBACZ,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC;oBAC7B,mEAAe,CAAC,QAAQ,EAAE;oBAC1B,2EAAmB;oBACnB,kFAAiB;iBAClB;aACF;;;;;;;;;;;;;;ACtBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiK;AAC7G;AAC0D;AACiF;;AAE/L;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AAC2B;;AAExC;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA,mBAAmB;AACnB,WAAW,EAGV;AACD;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,WAAW,EAWV;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAAO;AAC5C,8BAA8B,4CAAO;AACrC,kCAAkC,oDAAe;AACjD,4BAA4B,oDAAe;AAC3C,2BAA2B,oDAAe;AAC1C,0BAA0B,oDAAe;AACzC,iCAAiC,oDAAe;AAChD,+BAA+B,oDAAe;AAC9C,qCAAqC,oDAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAAiB;AAC1C;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mBAAmB,4BAA4B;AAC/C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kBAAkB,2BAA2B;AAC7C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,0BAA0B;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oCAAoC,+CAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,kDAAkD,4CAAO;AACzD;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,aAAa;AACb,mEAAmE,2DAAI,KAAK,gEAAS;AACrF;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,gEAAS,mBAAmB,8DAAO;AAChD;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAS;AACjB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,4BAA4B,6DAAgB;AAC5C,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,aAAa,KAAK,+CAAE;AACpB,SAAS;AACT;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,wBAAwB,+CAAU;AAClC,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA,QAAQ,gEAAS;AACjB;AACA;AACA,wDAAwD,iCAAiC,+DAAwB,CAAC,oDAAa,GAAG,+DAAwB,CAAC,yDAAW,MAAM;AAC5K,qBAAqB,+DAAwB,EAAE,yGAAyG;AACxJ,QAAQ,yDAAkB;AAC1B,KAAK;AACL;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,KAAK,EAAE,WAAW,2MAA2M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Y;AACZ;AACA;AACA,WAAW,iDAAI,CAAC,oEAAe,YAAY,gEAAS;AACpD,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,4CAA4C,0DAAG;AAC/C,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB,0BAA0B,0DAAa;AACvC,cAAc,0DAAG;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,sCAAsC,2BAA2B;AACjE;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,uDAAuD,0DAAa;AACpE,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,IAAI,kDAAK;AACT,cAAc,qEAAc,CAAC,0DAAa,gEAAgE,0DAAG;AAC7G,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,+BAA+B,gEAAS;AACxC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8BAA8B;AAC9B,KAAK;AACL;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,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","file":"dashboard-dashboard-module.js","sourcesContent":["import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { DashboardComponent } from './dashboard.component';\r\nimport { Routes, RouterModule } from '@angular/router';\r\nimport { TranslateModule } from '@ngx-translate/core';\r\nimport { YouTubePlayerModule } from '@angular/youtube-player';\r\nimport { FontAwesomeModule } from '@fortawesome/angular-fontawesome';\r\n\r\n\r\nconst routes: Routes = [\r\n  { path: '', component: DashboardComponent }\r\n];\r\n\r\n@NgModule({\r\n  declarations: [DashboardComponent],\r\n  imports: [\r\n    CommonModule,\r\n    RouterModule.forChild(routes),\r\n    TranslateModule.forChild(),\r\n    YouTubePlayerModule,\r\n    FontAwesomeModule\r\n  ]\r\n})\r\nexport class DashboardModule { }\r\n","import { Component, ChangeDetectionStrategy, ViewEncapsulation, NgZone, Optional, Inject, PLATFORM_ID, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, flatMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/youtube-player/youtube-player.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nimport * as ɵngcc0 from '@angular/core';\n\nconst _c0 = [\"youtubeContainer\"];\nconst DEFAULT_PLAYER_WIDTH = 640;\n/** @type {?} */\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * @record\n */\nfunction Player() { }\nif (false) {\n    /** @type {?|undefined} */\n    Player.prototype.videoId;\n}\n/**\n * Object used to store the state of the player if the\n * user tries to interact with the API before it has been loaded.\n * @record\n */\nfunction PendingPlayerState() { }\nif (false) {\n    /** @type {?|undefined} */\n    PendingPlayerState.prototype.playbackState;\n    /** @type {?|undefined} */\n    PendingPlayerState.prototype.playbackRate;\n    /** @type {?|undefined} */\n    PendingPlayerState.prototype.volume;\n    /** @type {?|undefined} */\n    PendingPlayerState.prototype.muted;\n    /** @type {?|undefined} */\n    PendingPlayerState.prototype.seek;\n}\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\nclass YouTubePlayer {\n    /**\n     * @param {?} _ngZone\n     * @param {?=} platformId\n     */\n    constructor(_ngZone, \n    /**\n     * @deprecated `platformId` parameter to become required.\n     * @breaking-change 10.0.0\n     */\n    platformId) {\n        this._ngZone = _ngZone;\n        this._youtubeContainer = new Subject();\n        this._destroyed = new Subject();\n        this._playerChanges = new BehaviorSubject(undefined);\n        this._videoId = new BehaviorSubject(undefined);\n        this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n        this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n        this._startSeconds = new BehaviorSubject(undefined);\n        this._endSeconds = new BehaviorSubject(undefined);\n        this._suggestedQuality = new BehaviorSubject(undefined);\n        /**\n         * Outputs are direct proxies from the player itself.\n         */\n        this.ready = this._getLazyEmitter('onReady');\n        this.stateChange = this._getLazyEmitter('onStateChange');\n        this.error = this._getLazyEmitter('onError');\n        this.apiChange = this._getLazyEmitter('onApiChange');\n        this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n        this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n        // @breaking-change 10.0.0 Remove null check for `platformId`.\n        this._isBrowser =\n            platformId ? isPlatformBrowser(platformId) : typeof window === 'object' && !!window;\n    }\n    /**\n     * YouTube Video ID to view\n     * @return {?}\n     */\n    get videoId() { return this._videoId.value; }\n    /**\n     * @param {?} videoId\n     * @return {?}\n     */\n    set videoId(videoId) {\n        this._videoId.next(videoId);\n    }\n    /**\n     * Height of video player\n     * @return {?}\n     */\n    get height() { return this._height.value; }\n    /**\n     * @param {?} height\n     * @return {?}\n     */\n    set height(height) {\n        this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n    }\n    /**\n     * Width of video player\n     * @return {?}\n     */\n    get width() { return this._width.value; }\n    /**\n     * @param {?} width\n     * @return {?}\n     */\n    set width(width) {\n        this._width.next(width || DEFAULT_PLAYER_WIDTH);\n    }\n    /**\n     * The moment when the player is supposed to start playing\n     * @param {?} startSeconds\n     * @return {?}\n     */\n    set startSeconds(startSeconds) {\n        this._startSeconds.next(startSeconds);\n    }\n    /**\n     * The moment when the player is supposed to stop playing\n     * @param {?} endSeconds\n     * @return {?}\n     */\n    set endSeconds(endSeconds) {\n        this._endSeconds.next(endSeconds);\n    }\n    /**\n     * The suggested quality of the player\n     * @param {?} suggestedQuality\n     * @return {?}\n     */\n    set suggestedQuality(suggestedQuality) {\n        this._suggestedQuality.next(suggestedQuality);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        // Don't do anything if we're not in a browser environment.\n        if (!this._isBrowser) {\n            return;\n        }\n        /** @type {?} */\n        let iframeApiAvailableObs = of(true);\n        if (!window.YT) {\n            if (this.showBeforeIframeApiLoads) {\n                throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' +\n                    'Please install the YouTube Player API Reference for iframe Embeds: ' +\n                    'https://developers.google.com/youtube/iframe_api_reference');\n            }\n            /** @type {?} */\n            const iframeApiAvailableSubject = new Subject();\n            this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n            window.onYouTubeIframeAPIReady = (/**\n             * @return {?}\n             */\n            () => {\n                if (this._existingApiReadyCallback) {\n                    this._existingApiReadyCallback();\n                }\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => iframeApiAvailableSubject.next(true)));\n            });\n            iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n        }\n        // An observable of the currently loaded player.\n        /** @type {?} */\n        const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._ngZone).pipe(waitUntilReady((/**\n         * @param {?} player\n         * @return {?}\n         */\n        player => {\n            // Destroy the player if loading was aborted so that we don't end up leaking memory.\n            if (!playerIsReady(player)) {\n                player.destroy();\n            }\n        })), takeUntil(this._destroyed), publish());\n        // Set up side effects to bind inputs to the player.\n        playerObs.subscribe((/**\n         * @param {?} player\n         * @return {?}\n         */\n        player => {\n            this._player = player;\n            this._playerChanges.next(player);\n            if (player && this._pendingPlayerState) {\n                this._initializePlayer(player, this._pendingPlayerState);\n            }\n            this._pendingPlayerState = undefined;\n        }));\n        bindSizeToPlayer(playerObs, this._width, this._height);\n        bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n        bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed);\n        // After all of the subscriptions are set up, connect the observable.\n        ((/** @type {?} */ (playerObs))).connect();\n    }\n    /**\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 11.0.0\n     * @return {?}\n     */\n    createEventsBoundInZone() {\n        return {};\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._player) {\n            this._player.destroy();\n            window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n        }\n        this._playerChanges.complete();\n        this._videoId.complete();\n        this._height.complete();\n        this._width.complete();\n        this._startSeconds.complete();\n        this._endSeconds.complete();\n        this._suggestedQuality.complete();\n        this._youtubeContainer.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#playVideo\n     * @return {?}\n     */\n    playVideo() {\n        if (this._player) {\n            this._player.playVideo();\n        }\n        else {\n            this._getPendingState().playbackState = 1 /* PLAYING */;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#pauseVideo\n     * @return {?}\n     */\n    pauseVideo() {\n        if (this._player) {\n            this._player.pauseVideo();\n        }\n        else {\n            this._getPendingState().playbackState = 2 /* PAUSED */;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#stopVideo\n     * @return {?}\n     */\n    stopVideo() {\n        if (this._player) {\n            this._player.stopVideo();\n        }\n        else {\n            // It seems like YouTube sets the player to CUED when it's stopped.\n            this._getPendingState().playbackState = 5 /* CUED */;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#seekTo\n     * @param {?} seconds\n     * @param {?} allowSeekAhead\n     * @return {?}\n     */\n    seekTo(seconds, allowSeekAhead) {\n        if (this._player) {\n            this._player.seekTo(seconds, allowSeekAhead);\n        }\n        else {\n            this._getPendingState().seek = { seconds, allowSeekAhead };\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#mute\n     * @return {?}\n     */\n    mute() {\n        if (this._player) {\n            this._player.mute();\n        }\n        else {\n            this._getPendingState().muted = true;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#unMute\n     * @return {?}\n     */\n    unMute() {\n        if (this._player) {\n            this._player.unMute();\n        }\n        else {\n            this._getPendingState().muted = false;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#isMuted\n     * @return {?}\n     */\n    isMuted() {\n        if (this._player) {\n            return this._player.isMuted();\n        }\n        if (this._pendingPlayerState) {\n            return !!this._pendingPlayerState.muted;\n        }\n        return false;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#setVolume\n     * @param {?} volume\n     * @return {?}\n     */\n    setVolume(volume) {\n        if (this._player) {\n            this._player.setVolume(volume);\n        }\n        else {\n            this._getPendingState().volume = volume;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getVolume\n     * @return {?}\n     */\n    getVolume() {\n        if (this._player) {\n            return this._player.getVolume();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n            return this._pendingPlayerState.volume;\n        }\n        return 0;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate\n     * @param {?} playbackRate\n     * @return {?}\n     */\n    setPlaybackRate(playbackRate) {\n        if (this._player) {\n            return this._player.setPlaybackRate(playbackRate);\n        }\n        else {\n            this._getPendingState().playbackRate = playbackRate;\n        }\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate\n     * @return {?}\n     */\n    getPlaybackRate() {\n        if (this._player) {\n            return this._player.getPlaybackRate();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n            return this._pendingPlayerState.playbackRate;\n        }\n        return 0;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates\n     * @return {?}\n     */\n    getAvailablePlaybackRates() {\n        return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction\n     * @return {?}\n     */\n    getVideoLoadedFraction() {\n        return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getPlayerState\n     * @return {?}\n     */\n    getPlayerState() {\n        if (!this._isBrowser || !window.YT) {\n            return undefined;\n        }\n        if (this._player) {\n            return this._player.getPlayerState();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n            return this._pendingPlayerState.playbackState;\n        }\n        return -1 /* UNSTARTED */;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime\n     * @return {?}\n     */\n    getCurrentTime() {\n        if (this._player) {\n            return this._player.getCurrentTime();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n            return this._pendingPlayerState.seek.seconds;\n        }\n        return 0;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality\n     * @return {?}\n     */\n    getPlaybackQuality() {\n        return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels\n     * @return {?}\n     */\n    getAvailableQualityLevels() {\n        return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getDuration\n     * @return {?}\n     */\n    getDuration() {\n        return this._player ? this._player.getDuration() : 0;\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl\n     * @return {?}\n     */\n    getVideoUrl() {\n        return this._player ? this._player.getVideoUrl() : '';\n    }\n    /**\n     * See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode\n     * @return {?}\n     */\n    getVideoEmbedCode() {\n        return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /**\n     * Gets an object that should be used to store the temporary API state.\n     * @private\n     * @return {?}\n     */\n    _getPendingState() {\n        if (!this._pendingPlayerState) {\n            this._pendingPlayerState = {};\n        }\n        return this._pendingPlayerState;\n    }\n    /**\n     * Initializes a player from a temporary state.\n     * @private\n     * @param {?} player\n     * @param {?} state\n     * @return {?}\n     */\n    _initializePlayer(player, state) {\n        const { playbackState, playbackRate, volume, muted, seek } = state;\n        switch (playbackState) {\n            case 1 /* PLAYING */:\n                player.playVideo();\n                break;\n            case 2 /* PAUSED */:\n                player.pauseVideo();\n                break;\n            case 5 /* CUED */:\n                player.stopVideo();\n                break;\n        }\n        if (playbackRate != null) {\n            player.setPlaybackRate(playbackRate);\n        }\n        if (volume != null) {\n            player.setVolume(volume);\n        }\n        if (muted != null) {\n            muted ? player.mute() : player.unMute();\n        }\n        if (seek != null) {\n            player.seekTo(seek.seconds, seek.allowSeekAhead);\n        }\n    }\n    /**\n     * Gets an observable that adds an event listener to the player when a user subscribes to it.\n     * @private\n     * @template T\n     * @param {?} name\n     * @return {?}\n     */\n    _getLazyEmitter(name) {\n        // Start with the stream of players. This way the events will be transferred\n        // over to the new player if it gets swapped out under-the-hood.\n        return this._playerChanges.pipe(\n        // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n        // player is changed. If there's no player, return an observable that never emits.\n        switchMap((/**\n         * @param {?} player\n         * @return {?}\n         */\n        player => {\n            return player ? fromEventPattern((/**\n             * @param {?} listener\n             * @return {?}\n             */\n            (listener) => {\n                player.addEventListener(name, listener);\n            }), (/**\n             * @param {?} listener\n             * @return {?}\n             */\n            (listener) => {\n                // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n                // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n                // prevent the entire stream from erroring out.\n                try {\n                    player.removeEventListener(name, listener);\n                }\n                catch (_a) { }\n            })) : of();\n        })), (\n        // By default we run all the API interactions outside the zone\n        // so we have to bring the events back in manually when they emit.\n        /**\n         * @param {?} source\n         * @return {?}\n         */\n        (source) => new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        observer => source.subscribe({\n            next: (/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => this._ngZone.run((/**\n             * @return {?}\n             */\n            () => observer.next(value)))),\n            error: (/**\n             * @param {?} error\n             * @return {?}\n             */\n            error => observer.error(error)),\n            complete: (/**\n             * @return {?}\n             */\n            () => observer.complete())\n        })))), \n        // Ensures that everything is cleared out on destroy.\n        takeUntil(this._destroyed));\n    }\n}\nYouTubePlayer.ɵfac = function YouTubePlayer_Factory(t) { return new (t || YouTubePlayer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID, 8)); };\nYouTubePlayer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YouTubePlayer, selectors: [[\"youtube-player\"]], viewQuery: function YouTubePlayer_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, true);\n    } if (rf & 2) {\n        var _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.youtubeContainer = _t.first);\n    } }, inputs: { videoId: \"videoId\", height: \"height\", width: \"width\", startSeconds: \"startSeconds\", endSeconds: \"endSeconds\", suggestedQuality: \"suggestedQuality\", showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\" }, outputs: { ready: \"ready\", stateChange: \"stateChange\", error: \"error\", apiChange: \"apiChange\", playbackQualityChange: \"playbackQualityChange\", playbackRateChange: \"playbackRateChange\" }, decls: 2, vars: 0, consts: [[\"youtubeContainer\", \"\"]], template: function YouTubePlayer_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", null, 0);\n    } }, encapsulation: 2, changeDetection: 0 });\n/** @nocollapse */\nYouTubePlayer.ctorParameters = () => [\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Optional }, { type: Inject, args: [PLATFORM_ID,] }] }\n];\nYouTubePlayer.propDecorators = {\n    videoId: [{ type: Input }],\n    height: [{ type: Input }],\n    width: [{ type: Input }],\n    startSeconds: [{ type: Input }],\n    endSeconds: [{ type: Input }],\n    suggestedQuality: [{ type: Input }],\n    showBeforeIframeApiLoads: [{ type: Input }],\n    ready: [{ type: Output }],\n    stateChange: [{ type: Output }],\n    error: [{ type: Output }],\n    apiChange: [{ type: Output }],\n    playbackQualityChange: [{ type: Output }],\n    playbackRateChange: [{ type: Output }],\n    youtubeContainer: [{ type: ViewChild, args: ['youtubeContainer',] }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YouTubePlayer, [{\n        type: Component,\n        args: [{\n                selector: 'youtube-player',\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                // This div is *replaced* by the YouTube player embed.\n                template: '<div #youtubeContainer></div>'\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: Object, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ready: [{\n            type: Output\n        }], stateChange: [{\n            type: Output\n        }], error: [{\n            type: Output\n        }], apiChange: [{\n            type: Output\n        }], playbackQualityChange: [{\n            type: Output\n        }], playbackRateChange: [{\n            type: Output\n        }], videoId: [{\n            type: Input\n        }], height: [{\n            type: Input\n        }], width: [{\n            type: Input\n        }], startSeconds: [{\n            type: Input\n        }], endSeconds: [{\n            type: Input\n        }], suggestedQuality: [{\n            type: Input\n        }], showBeforeIframeApiLoads: [{\n            type: Input\n        }], youtubeContainer: [{\n            type: ViewChild,\n            args: ['youtubeContainer']\n        }] }); })();\nif (false) {\n    /**\n     * Whether we're currently rendering inside a browser.\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._isBrowser;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._youtubeContainer;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._destroyed;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._player;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._existingApiReadyCallback;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._pendingPlayerState;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._playerChanges;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._videoId;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._height;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._width;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._startSeconds;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._endSeconds;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._suggestedQuality;\n    /**\n     * Whether the iframe will attempt to load regardless of the status of the api on the\n     * page. Set this to true if you don't want the `onYouTubeIframeAPIReady` field to be\n     * set on the global window.\n     * @type {?}\n     */\n    YouTubePlayer.prototype.showBeforeIframeApiLoads;\n    /**\n     * Outputs are direct proxies from the player itself.\n     * @type {?}\n     */\n    YouTubePlayer.prototype.ready;\n    /** @type {?} */\n    YouTubePlayer.prototype.stateChange;\n    /** @type {?} */\n    YouTubePlayer.prototype.error;\n    /** @type {?} */\n    YouTubePlayer.prototype.apiChange;\n    /** @type {?} */\n    YouTubePlayer.prototype.playbackQualityChange;\n    /** @type {?} */\n    YouTubePlayer.prototype.playbackRateChange;\n    /**\n     * The element that will be replaced by the iframe.\n     * @type {?}\n     */\n    YouTubePlayer.prototype.youtubeContainer;\n    /**\n     * @type {?}\n     * @private\n     */\n    YouTubePlayer.prototype._ngZone;\n}\n/**\n * Listens to changes to the given width and height and sets it on the player.\n * @param {?} playerObs\n * @param {?} widthObs\n * @param {?} heightObs\n * @return {?}\n */\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n    return combineLatest([playerObs, widthObs, heightObs])\n        .subscribe((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([player, width, height]) => player && player.setSize(width, height)));\n}\n/**\n * Listens to changes from the suggested quality and sets it on the given player.\n * @param {?} playerObs\n * @param {?} suggestedQualityObs\n * @return {?}\n */\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n    return combineLatest([\n        playerObs,\n        suggestedQualityObs\n    ]).subscribe((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality)));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param {?} onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n * @return {?}\n */\nfunction waitUntilReady(onAbort) {\n    return flatMap((/**\n     * @param {?} player\n     * @return {?}\n     */\n    player => {\n        if (!player) {\n            return of(undefined);\n        }\n        if (playerIsReady(player)) {\n            return of((/** @type {?} */ (player)));\n        }\n        // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n        // The player is not initialized fully until the ready is called.\n        return new Observable((/**\n         * @param {?} emitter\n         * @return {?}\n         */\n        emitter => {\n            /** @type {?} */\n            let aborted = false;\n            /** @type {?} */\n            let resolved = false;\n            /** @type {?} */\n            const onReady = (/**\n             * @param {?} event\n             * @return {?}\n             */\n            (event) => {\n                resolved = true;\n                if (!aborted) {\n                    event.target.removeEventListener('onReady', onReady);\n                    emitter.next(event.target);\n                }\n            });\n            player.addEventListener('onReady', onReady);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                aborted = true;\n                if (!resolved) {\n                    onAbort(player);\n                }\n            });\n        })).pipe(take(1), startWith(undefined));\n    }));\n}\n/**\n * Create an observable for the player based on the given options.\n * @param {?} youtubeContainer\n * @param {?} videoIdObs\n * @param {?} iframeApiAvailableObs\n * @param {?} widthObs\n * @param {?} heightObs\n * @param {?} ngZone\n * @return {?}\n */\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, ngZone) {\n    /** @type {?} */\n    const playerOptions = videoIdObs\n        .pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([videoId, [width, height]]) => videoId ? ({ videoId, width, height }) : undefined)));\n    return combineLatest([youtubeContainer, playerOptions, of(ngZone)])\n        .pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/**\n * Skips the given observable until the other observable emits true, then emit the latest.\n * @template T\n * @param {?} notifier\n * @return {?}\n */\nfunction skipUntilRememberLatest(notifier) {\n    return pipe(combineLatest$1(notifier), skipWhile((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([_, doneSkipping]) => !doneSkipping)), map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([value]) => value)));\n}\n/**\n * Destroy the player if there are no options, or create the player if there are options.\n * @param {?} player\n * @param {?} __1\n * @return {?}\n */\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n    if (!videoOptions) {\n        if (player) {\n            player.destroy();\n        }\n        return;\n    }\n    if (player) {\n        return player;\n    }\n    // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n    // off a 250ms setInterval which will continually trigger change detection if we don't.\n    /** @type {?} */\n    const newPlayer = ngZone.runOutsideAngular((/**\n     * @return {?}\n     */\n    () => new YT.Player(container, videoOptions)));\n    // Bind videoId for future use.\n    newPlayer.videoId = videoOptions.videoId;\n    return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n * @param {?} playerObs\n * @param {?} videoIdObs\n * @param {?} startSecondsObs\n * @param {?} endSecondsObs\n * @param {?} suggestedQualityObs\n * @param {?} destroyed\n * @return {?}\n */\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n    /** @type {?} */\n    const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs])\n        .pipe(map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([startSeconds, endSeconds]) => ({ startSeconds, endSeconds }))));\n    // Only respond to changes in cue options if the player is not running.\n    /** @type {?} */\n    const filteredCueOptions = cueOptionsObs\n        .pipe(filterOnOther(playerObs, (/**\n     * @param {?} player\n     * @return {?}\n     */\n    player => !!player && !hasPlayerStarted(player))));\n    // If the video id changed, there's no reason to run 'cue' unless the player\n    // was initialized with a different video id.\n    /** @type {?} */\n    const changedVideoId = videoIdObs\n        .pipe(filterOnOther(playerObs, (/**\n     * @param {?} player\n     * @param {?} videoId\n     * @return {?}\n     */\n    (player, videoId) => !!player && player.videoId !== videoId)));\n    // If the player changed, there's no reason to run 'cue' unless there are cue options.\n    /** @type {?} */\n    const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), (/**\n     * @param {?} __0\n     * @param {?} player\n     * @return {?}\n     */\n    ([videoId, cueOptions], player) => !!player &&\n        (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds))));\n    merge(changedPlayer, changedVideoId, filteredCueOptions)\n        .pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([_, values]) => values)), takeUntil(destroyed))\n        .subscribe((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([player, videoId, cueOptions, suggestedQuality]) => {\n        if (!videoId || !player) {\n            return;\n        }\n        player.videoId = videoId;\n        player.cueVideoById(Object.assign({ videoId,\n            suggestedQuality }, cueOptions));\n    }));\n}\n/**\n * @param {?} player\n * @return {?}\n */\nfunction hasPlayerStarted(player) {\n    /** @type {?} */\n    const state = player.getPlayerState();\n    return state !== -1 /* UNSTARTED */ && state !== 5 /* CUED */;\n}\n/**\n * @param {?} player\n * @return {?}\n */\nfunction playerIsReady(player) {\n    return 'getPlayerStatus' in player;\n}\n/**\n * Combines the two observables temporarily for the filter function.\n * @template R, T\n * @param {?} otherObs\n * @param {?} filterFn\n * @return {?}\n */\nfunction filterOnOther(otherObs, filterFn) {\n    return pipe(withLatestFrom(otherObs), filter((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([value, other]) => filterFn(other, value))), map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ([value]) => value)));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/youtube-player/youtube-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst COMPONENTS = [YouTubePlayer];\nclass YouTubePlayerModule {\n}\nYouTubePlayerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: YouTubePlayerModule });\nYouTubePlayerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function YouTubePlayerModule_Factory(t) { return new (t || YouTubePlayerModule)(); } });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(YouTubePlayerModule, { declarations: [YouTubePlayer], exports: [YouTubePlayer] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YouTubePlayerModule, [{\n        type: NgModule,\n        args: [{\n                declarations: COMPONENTS,\n                exports: COMPONENTS\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/youtube-player/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { YouTubePlayer, YouTubePlayerModule };\n\n//# sourceMappingURL=youtube-player.js.map","import { Route } from '@angular/compiler/src/core';\r\nimport { NgZone } from '@angular/core';\r\nimport { Component, OnInit } from '@angular/core';\r\nimport { Router } from '@angular/router';\r\nimport { LayoutMenuItem } from 'ax-toolbox';\r\nimport { SetData } from 'src/app/shared/models/_basic/set-data';\r\nimport { AppMenuService } from 'src/app/shared/services/app-menu/app-menu.service';\r\n\r\n@Component({\r\n  selector: 'app-dashboard',\r\n  templateUrl: './dashboard.component.html',\r\n  styleUrls: ['./dashboard.component.scss']\r\n})\r\nexport class DashboardComponent implements OnInit {\r\n\r\n  _menuItems: LayoutMenuItem[] = [];\r\n  \r\n  // se genera el ngZone para recargar completamente lo que sería la vista para que cargue los elementos correctamente\r\n  constructor(private serviceMenu: AppMenuService ,private zone: NgZone, private ruta: Router) { }\r\n\r\n  ngOnInit(): void {\r\n    this.initMenuItems();\r\n  }\r\n\r\n  private async initMenuItems(){\r\n    this._menuItems = await this.serviceMenu.getMenuItems();\r\n  }\r\n\r\n  navegation(num: number) {\r\n    if (num == 1) {\r\n      this.zone.run((data) => {\r\n        this.ruta.navigate(['/empleados/employees/datatable'])\r\n      })\r\n    } else if (num == 2) {\r\n      this.zone.run((data) => {\r\n        this.ruta.navigate(['/empleados/employees/new'])\r\n      })\r\n    } else if (num == 3) {\r\n      this.zone.run((data) => {\r\n        this.ruta.navigate(['/empleados/project/datatable'])\r\n      })\r\n    } else if (num == 4) {\r\n      this.zone.run((data) => {\r\n        this.ruta.navigate(['/empleados/project/new'])\r\n      })\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport class YouTubeLink extends SetData<YouTubeLink> {\r\n  videoId: string;\r\n  quality: YT.SuggestedVideoQuality = 'highres';\r\n}\r\n","<h1 class=\"section-title my-4\">{{'PAGE.DASHBOARD.TITLE' | translate}}</h1>\r\n<!--ol>\r\n    <li>Empleados</li>\r\n        <ul>\r\n            <li><a type=\"button\" (click)=\"navegation(1)\">Lista</a></li>\r\n            <li><a type=\"button\" (click)=\"navegation(2)\">Nuevo</a></li>\r\n        </ul>\r\n    <li>Proyectos</li>\r\n        <ul>\r\n            <li><a type=\"button\" (click)=\"navegation(3)\">Lista</a></li>\r\n            <li><a type=\"button\" (click)=\"navegation(4)\">Nuevo</a></li>\r\n        </ul>\r\n</ol\r\n\r\nAquí abajo primero estamos haciendo un recorrido por los elementos del menú rescatados antes\r\nImportante para que se traduzca añadir el pipe translate\r\n-->\r\n<div class=\"row menu-card-container\">\r\n    <div *ngFor=\"let i of _menuItems\" class=\"col-12 col-sm-6 col-md-4 col-lg-3 col-xl-2 mb-2\">\r\n        <div class=\"card text-center mx-auto\">\r\n            <div class=\"card-header bg-primary text-light position-relative\">\r\n                <fa-icon *ngIf=\"i.iconPreffix && i.iconName\" [icon]=\"[i.iconPreffix, i.iconName]\" class=\"mr-1\">\r\n                </fa-icon>\r\n                {{i.label | translate}}\r\n                <a *ngIf=\"i.routerLinkCommands && i.routerLinkCommands.length > 0\" class=\"stretched-link\"\r\n                    [routerLink]=\"i.routerLinkCommands\"></a>\r\n            </div>\r\n            <div *ngIf=\"i.children && i.children.length > 0\" class=\"card-body py-0\">\r\n                <div *ngFor=\"let c of i.children; let index = index\" class=\"py-3 position-relative border-bottom\"\r\n                    [ngClass]=\"{'border-bottom-0': index === (i.children && i.children.length - 1)}\">\r\n                    <fa-icon *ngIf=\"c.iconPreffix && c.iconName\" [icon]=\"[c.iconPreffix, c.iconName]\" class=\"mr-1\">\r\n                    </fa-icon>\r\n                    {{c.label | translate}}\r\n                    <a *ngIf=\"c.routerLinkCommands && c.routerLinkCommands.length > 0\" class=\"stretched-link\"\r\n                        [routerLink]=\"c.routerLinkCommands\"></a>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n"],"sourceRoot":"webpack:///"}